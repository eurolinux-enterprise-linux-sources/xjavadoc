/**
 * This file is a modified version of one originally found in the
 * VTransformer Examples directory of JavaCC1_1. It has been
 * modified to accept Java source code for Java 1.2. Basically,
 * this means a new key word was added, 'strictfp', and that keyword
 * added to the appropriate productions and LOOKAHEADs (where other,
 * similar keywords are listed as possible choices). This involved
 * changing 11 lines.
 *
 * Some other minor changes were made, which can be found by doing
 * a search on 'DW, 7/99'.
 *
 * The goal of this effort was for the grammar to be able to parse
 * any legal Java 1.2 source code. It does not reject all illegal
 * cases, but neither did the original. Plus, when it comes to
 * the new 'strictfp' keyword, the Java Compiler from Sun (JDK1.2.1)
 * also does not reject all illegal cases, as defined by the
 * "Updates" document found at
 *       http://java.sun.com/docs/books/jls/strictfp-changes.pdf
 * (see the testcases.txt file for details).
 *
 * David Williams, 7/99
 * ===================================================================
 *
 *
 * Copyright (C) 1996, 1997 Sun Microsystems Inc.
 *
 * Use of this file and the system it is part of is constrained by the
 * file COPYRIGHT in the root directory of this system.  You may, however,
 * make any modifications you wish to this file.
 *
 * Java files generated by running JavaCC on this file (or modified versions
 * of this file) may be used in exactly the same manner as Java files
 * generated from any grammar developed by you.
 *
 * Author: Sriram Sankar
 * Author: Aslak Hellesøy (XJavaDoc additions)
 * Date: 3/5/97
 *
 * This file contains a Java grammar and actions that implement a front-end.
 *
 */

PARSER_BEGIN(@parser-class@)

package xjavadoc;

import java.lang.reflect.Modifier;
import java.util.*;
import java.io.InputStream;
import java.io.ByteArrayInputStream;

public class @parser-class@ implements JavaParser
{
   private XJavaDoc _xJavaDoc;
   private XTagFactory _tagFactory;
   
   private String _packageName = "";
   // The class we're currently parsing
   private SourceClass _sourceClass;
   private Stack _sourceClassStack = new Stack();
   
   // Flag that tells us if the main class/interface has been parsed.
   // Needed to support more than one "outer" class in one source.
   private boolean _hasParsedMain = false;


   private static final void setToken(AbstractProgramElement element, Token token) {
       element.setToken( token );
       //element.setDoc(getJavaDocSpecialToken( token ));
   }

   private final void clearNameBuffer() {
      if( _nameBuffer.length() > 0 ) {
         _nameBuffer.delete(0, _nameBuffer.length());
      }
   }

   private final StringBuffer _nameBuffer = new StringBuffer();

   private static class Parameter {
      public String type;
      public String name;
      public int dimension;
   }
   private Parameter _parameter;

   // Reference to the first token in a Name() production.
   private Token _nameToken;
   
   /**
    * Should be called before UnmodifiedClassDeclaration or UnmodifiedInterfaceDeclaration
    */
   private SourceClass pushAndGet() {
       // Push a source class onto the stack. If the stack is empty,
       // push the outer class. Otherwise, instantiate a new (inner) class
       // and push that instead.
       SourceClass clazz = null;
       if( _sourceClassStack.isEmpty() ) {
          // It's an outer class. In rare cases there is more than one outer classes
          // in one source. handle that here.
          if( !_hasParsedMain ) {
             // the usual case
             clazz = _sourceClass;
          } else {
             // the source contains more than one classes
             clazz = new SourceClass(_sourceClass, 0, _tagFactory);
          }
       } else {
          clazz = new SourceClass(currentClass(), _tagFactory);
       }
       _sourceClassStack.push(clazz);
       return clazz;
   }
   
   /**
    * Should be called after UnmodifiedClassDeclaration or UnmodifiedInterfaceDeclaration
    */
   private void popAndAddInner() {
    SourceClass clazz = (SourceClass) _sourceClassStack.pop();
    if( clazz.getContainingClass() != null ) {
        // Add the class as an inner class
        currentClass().addInnerClass(clazz);
        _xJavaDoc.addSourceClass(clazz);
    }
   }

   private SourceClass currentClass() {
       return (SourceClass)_sourceClassStack.peek();
   }

    /** 
     * This constructor was added to allow the re-use of parsers.
     * The normal constructor takes a single argument which 
     * an InputStream. This simply creates a re-usable parser
     * object, we satisfy the requirement of an InputStream
     * by using a newline character as an input stream.
     */
    public @parser-class@( XJavaDoc xJavaDoc, XTagFactory tagFactory )
    {
        this(new ByteArrayInputStream("\n".getBytes()));
        _xJavaDoc = xJavaDoc;
        _tagFactory = tagFactory;
    }

    /** 
     * This was also added to allow parsers to be
     * re-usable. Normal JavaCC use entails passing an
     * input stream to the constructor and the parsing
     * process is carried out once. We want to be able
     * to re-use parsers: we do this by adding this
     * method and re-initializing the lexer with
     * the new stream that we want parsed.
     */
    public void populate(SourceClass sourceClass)
        throws ParseException
    {
        _sourceClass = sourceClass;
	
	// Reset state
	_sourceClassStack.clear();
	_packageName = "";
	_parameter = new Parameter();
	_nameToken = null;
	clearNameBuffer();
        
        try
        {
        
            // now reinit the Parser with this CharStream
            // 
            ReInit(sourceClass.getReader());

            // Start the parsing.
            CompilationUnit( sourceClass );
        }
        catch (ParseException pe)
        {
            throw new ParseException (pe.currentToken, 
                pe.expectedTokenSequences, pe.tokenImage);
        }
        catch (TokenMgrError tme) 
        {
            throw new ParseException("Lexical error: " + tme.toString());
        }
    }        
}

PARSER_END(@parser-class@)


/* WHITE SPACE */
SPECIAL_TOKEN :
{
  " "
| "\t"
| "\n"
| "\r"
| "\f"
}

/* COMMENTS */

MORE :
{
  "//" : IN_SINGLE_LINE_COMMENT
|
  <"/**" ~["/"]> { input_stream.backup(1); } : IN_FORMAL_COMMENT
|
  "/*" : IN_MULTI_LINE_COMMENT
}

<IN_SINGLE_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <SINGLE_LINE_COMMENT: "\n" | "\r" | "\r\n" > : DEFAULT
}

<IN_FORMAL_COMMENT>
SPECIAL_TOKEN :
{
  <FORMAL_COMMENT: "*/" > : DEFAULT
}

<IN_MULTI_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <MULTI_LINE_COMMENT: "*/" > : DEFAULT
}

<IN_SINGLE_LINE_COMMENT,IN_FORMAL_COMMENT,IN_MULTI_LINE_COMMENT>
MORE :
{
  < ~[] >
}

/* RESERVED WORDS AND LITERALS */

TOKEN :
{
  < ABSTRACT: "abstract" >
| < BOOLEAN: "boolean" >
| < BREAK: "break" >
| < BYTE: "byte" >
| < CASE: "case" >
| < CATCH: "catch" >
| < CHAR: "char" >
| < CLASS: "class" >
| < CONST: "const" >
| < CONTINUE: "continue" >
| < _DEFAULT: "default" >
| < DO: "do" >
| < DOUBLE: "double" >
| < ELSE: "else" >
| < EXTENDS: "extends" >
| < FALSE: "false" >
| < FINAL: "final" >
| < FINALLY: "finally" >
| < FLOAT: "float" >
| < FOR: "for" >
| < GOTO: "goto" >
| < IF: "if" >
| < IMPLEMENTS: "implements" >
| < IMPORT: "import" >
| < INSTANCEOF: "instanceof" >
| < INT: "int" >
| < INTERFACE: "interface" >
| < LONG: "long" >
| < NATIVE: "native" >
| < NEW: "new" >
| < NULL: "null" >
| < PACKAGE: "package">
| < PRIVATE: "private" >
| < PROTECTED: "protected" >
| < PUBLIC: "public" >
| < RETURN: "return" >
| < SHORT: "short" >
| < STATIC: "static" >
| < SUPER: "super" >
| < SWITCH: "switch" >
| < SYNCHRONIZED: "synchronized" >
| < THIS: "this" >
| < THROW: "throw" >
| < THROWS: "throws" >
| < TRANSIENT: "transient" >
| < TRUE: "true" >
| < TRY: "try" >
| < VOID: "void" >
| < VOLATILE: "volatile" >
| < WHILE: "while" >
| < STRICTFP: "strictfp" >
| < ASSERT: "assert" >
}

/* LITERALS */

TOKEN :
{
  < INTEGER_LITERAL:
        <DECIMAL_LITERAL> (["l","L"])?
      | <HEX_LITERAL> (["l","L"])?
      | <OCTAL_LITERAL> (["l","L"])?
  >
|
  < #DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])* >
|
  < #HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ >
|
  < #OCTAL_LITERAL: "0" (["0"-"7"])* >
|
  < FLOATING_POINT_LITERAL:
        (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? (["f","F","d","D"])?
      | "." (["0"-"9"])+ (<EXPONENT>)? (["f","F","d","D"])?
      | (["0"-"9"])+ <EXPONENT> (["f","F","d","D"])?
      | (["0"-"9"])+ (<EXPONENT>)? ["f","F","d","D"]
  >
|
  < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
|
  < CHARACTER_LITERAL:
      "'"
      (   (~["'","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )
      "'"
  >
|
  < STRING_LITERAL:
      "\""
      (   (~["\"","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )*
      "\""
  >
}

/* IDENTIFIERS */

TOKEN :
{
  < IDENTIFIER: <LETTER> (<LETTER>|<DIGIT>)* >
|
  < #LETTER:
      [
       "\u0024",
       "\u0041"-"\u005a",
       "\u005f",
       "\u0061"-"\u007a",
       "\u00c0"-"\u00d6",
       "\u00d8"-"\u00f6",
       "\u00f8"-"\u00ff",
       "\u0100"-"\u1fff",
       "\u3040"-"\u318f",
       "\u3300"-"\u337f",
       "\u3400"-"\u3d2d",
       "\u4e00"-"\u9fff",
       "\uf900"-"\ufaff"
      ]
  >
|
  < #DIGIT:
      [
       "\u0030"-"\u0039",
       "\u0660"-"\u0669",
       "\u06f0"-"\u06f9",
       "\u0966"-"\u096f",
       "\u09e6"-"\u09ef",
       "\u0a66"-"\u0a6f",
       "\u0ae6"-"\u0aef",
       "\u0b66"-"\u0b6f",
       "\u0be7"-"\u0bef",
       "\u0c66"-"\u0c6f",
       "\u0ce6"-"\u0cef",
       "\u0d66"-"\u0d6f",
       "\u0e50"-"\u0e59",
       "\u0ed0"-"\u0ed9",
       "\u1040"-"\u1049"
      ]
  >
}

/* SEPARATORS */

TOKEN :
{
  < LPAREN: "(" >
| < RPAREN: ")" >
| < LBRACE: "{" >
| < RBRACE: "}" >
| < LBRACKET: "[" >
| < RBRACKET: "]" >
| < SEMICOLON: ";" >
| < COMMA: "," >
| < DOT: "." >
}

/* OPERATORS */

TOKEN :
{
  < ASSIGN: "=" >
| < GT: ">" >
| < LT: "<" >
| < BANG: "!" >
| < TILDE: "~" >
| < HOOK: "?" >
| < COLON: ":" >
| < EQ: "==" >
| < LE: "<=" >
| < GE: ">=" >
| < NE: "!=" >
| < SC_OR: "||" >
| < SC_AND: "&&" >
| < INCR: "++" >
| < DECR: "--" >
| < PLUS: "+" >
| < MINUS: "-" >
| < STAR: "*" >
| < SLASH: "/" >
| < BIT_AND: "&" >
| < BIT_OR: "|" >
| < XOR: "^" >
| < REM: "%" >
| < LSHIFT: "<<" >
| < RSIGNEDSHIFT: ">>" >
| < RUNSIGNEDSHIFT: ">>>" >
| < PLUSASSIGN: "+=" >
| < MINUSASSIGN: "-=" >
| < STARASSIGN: "*=" >
| < SLASHASSIGN: "/=" >
| < ANDASSIGN: "&=" >
| < ORASSIGN: "|=" >
| < XORASSIGN: "^=" >
| < REMASSIGN: "%=" >
| < LSHIFTASSIGN: "<<=" >
| < RSIGNEDSHIFTASSIGN: ">>=" >
| < RUNSIGNEDSHIFTASSIGN: ">>>=" >
}


/*****************************************
 * THE JAVA LANGUAGE GRAMMAR STARTS HERE *
 *****************************************/

/*
 * Program structuring syntax follows.
 */

void CompilationUnit( SourceClass sourceClass ) :
{
}
{
  [ PackageDeclaration() ]
  ( ImportDeclaration() )*
  ( TypeDeclaration() )*
  <EOF>
  {
      // sourceClass must know about the CompilationUnit node
      // if it wants to mutate or print the code
      @set-compilation-unit@

    if( _sourceClassStack.size() != 0 ) {
       throw new IllegalStateException("There should be no more classes on the stack:" + _sourceClassStack.size());
    }
  }
}

void PackageDeclaration() :
{
}
{
  "package" _packageName=Name() ";"
  {
     _sourceClass.setContainingPackage( _packageName );
  }
}

void ImportDeclaration() :
{
   String importedElement;
   boolean isPackage = false;
}
{
  "import"
  importedElement=Name()
  [ "." "*" {
     isPackage = true;
  } ]
  ";"
  {
     if( isPackage ) {
        _sourceClass.addImportedPackage(importedElement);
     } else {
        _sourceClass.addImportedClass(importedElement);
     }
  }
}

void TypeDeclaration() :
{}
{
  LOOKAHEAD( ( "abstract" | "final" | "public" | "strictfp" )* "class" )
  ClassDeclaration() {
    _hasParsedMain = true;
  }
|
  InterfaceDeclaration() {
    _hasParsedMain = true;
  }
|
  ";"
}


/*
 * Declaration syntax follows.
 */

/*
Javadoc is stored in special tokens, and will either be
attached to the first modifier token (if there are any modifiers)
or to the first token in UnmodifiedClassDeclaration
*/
void ClassDeclaration() :
{
   SourceClass sourceClass = pushAndGet();
   Token t = null;
}
{
  (
    t="abstract" {
       setToken(sourceClass, t);
       sourceClass.addModifier( Modifier.ABSTRACT );
    }
  | t="final" {
       setToken(sourceClass, t);
       sourceClass.addModifier( Modifier.FINAL );
    }
  | t="public" {
       setToken(sourceClass, t);
       sourceClass.addModifier( Modifier.PUBLIC );
    }
  | t="strictfp" {
       setToken(sourceClass, t);
       sourceClass.addModifier( Modifier.STRICT );
    }
  )*
  UnmodifiedClassDeclaration()
  {
     popAndAddInner();
  }
}

void UnmodifiedClassDeclaration() :
{
   // Get a ref to the containing class
   SourceClass sourceClass = currentClass();

   Token ct;
   Token name = null;
   String superclass = null;
}
{
   ct="class" {
        if(sourceClass!=null) {
            setToken( sourceClass, ct );
            sourceClass.setInterface( false );
        }
   }
   name=<IDENTIFIER>
   {
    if(sourceClass.isInner()) {
        sourceClass.setName(name.image);
        _xJavaDoc.addPackageMaybe( _packageName ).addClass(sourceClass);
        _xJavaDoc.addSourceClass( sourceClass );
    } else {
        sourceClass.setQualifiedName(Util.getQualifiedNameFor(_packageName,name.image));
        _xJavaDoc.addPackageMaybe( _packageName ).addClass(sourceClass);
        _xJavaDoc.addSourceClass( sourceClass );
        sourceClass.resolveImportedClasses();
        
        // we're adding to xjavadoc in case we're an "extra" class (XJD-8).
        _xJavaDoc.addSourceClass(sourceClass);
    }
   }
   [ "extends" superclass=Name() ]
   [ "implements" Interfaces_NameList() ]
   ClassBody()
   {
    if( superclass != null ) {
        sourceClass.setSuperclass(superclass);
    } else {
        sourceClass.setSuperclass("java.lang.Object");
    }
   }
}

void ClassBody() :
{
}
{
  "{" ( ClassBodyDeclaration() )* "}" 
}

void NestedClassDeclaration() :
{
   SourceClass sourceClass = pushAndGet();
   Token t;
}
{
  (
    t="static" {
       sourceClass.addModifier( Modifier.STATIC );
       sourceClass.setToken( t );
    }
  | t="abstract" {
       sourceClass.addModifier( Modifier.ABSTRACT );
       sourceClass.setToken( t );
    }
  | t="final" {
       sourceClass.addModifier( Modifier.FINAL );
       sourceClass.setToken( t );
    }
  | t="public" {
       sourceClass.addModifier( Modifier.PUBLIC );
       sourceClass.setToken( t );
    }
  | t="protected" {
       sourceClass.addModifier( Modifier.PROTECTED );
       sourceClass.setToken( t );
    }
  | t="private" {
       sourceClass.addModifier( Modifier.PRIVATE );
       sourceClass.setToken( t );
    }
  | t="strictfp" {
       sourceClass.addModifier( Modifier.STRICT );
       sourceClass.setToken( t );
    }
  )*
  UnmodifiedClassDeclaration()
  {
    popAndAddInner();
  }
}

void ClassBodyDeclaration() :
{
   SourceClass sourceClass = currentClass();
}
{
  LOOKAHEAD(2)
  Initializer()
|
  LOOKAHEAD( ( "static" | "abstract" | "final" | "public" | "protected" | "private" | "strictfp")* "class" )
  NestedClassDeclaration()
|
  LOOKAHEAD( ( "static" | "abstract" | "final" | "public" | "protected" | "private" | "strictfp")* "interface" )
  NestedInterfaceDeclaration()
|
  LOOKAHEAD( [ "public" | "protected" | "private" ] Name() "(" )
  ConstructorDeclaration()
|
  LOOKAHEAD( MethodDeclarationLookahead() )
  MethodDeclaration()
|
  FieldDeclaration()
}

// This production is to determine lookahead only.
void MethodDeclarationLookahead() :
{}
{
  ( "public" | "protected" | "private" | "static" | "abstract" | "final" | "native" | "synchronized" | "strictfp")*
  ResultType(null) <IDENTIFIER> "("
}

void InterfaceDeclaration() :
{
   SourceClass sourceClass = pushAndGet();
   Token t = null;
}
{
  (
    t="abstract" {
       sourceClass.addModifier( Modifier.ABSTRACT );
       sourceClass.setToken( t );
    }
  | t="public" {
       sourceClass.addModifier( Modifier.PUBLIC );
       sourceClass.setToken( t );
    }
  | t="strictfp" {
       sourceClass.addModifier( Modifier.STRICT );
       sourceClass.setToken( t );
    }
  )*

  UnmodifiedInterfaceDeclaration()
  {
     popAndAddInner();
  }
}

void NestedInterfaceDeclaration() :
{
   SourceClass sourceClass = pushAndGet();
   Token t;
}
{
  (
    t="static" {
       sourceClass.addModifier( Modifier.STATIC );
       sourceClass.setToken( t );
    }
  | t="abstract" {
       sourceClass.addModifier( Modifier.ABSTRACT );
       sourceClass.setToken( t );
    }
  | t="final" {
       sourceClass.addModifier( Modifier.FINAL );
       sourceClass.setToken( t );
    }
  | t="public" {
       sourceClass.addModifier( Modifier.PUBLIC );
       sourceClass.setToken( t );
    }
  | t="protected" {
       sourceClass.addModifier( Modifier.PROTECTED );
       sourceClass.setToken( t );
    }
  | t="private" {
       sourceClass.addModifier( Modifier.PRIVATE );
       sourceClass.setToken( t );
    }
  | t="strictfp" {
       sourceClass.addModifier( Modifier.STRICT );
       sourceClass.setToken( t );
    }
  )*
  UnmodifiedInterfaceDeclaration()
  {
    popAndAddInner();
  }
}

void UnmodifiedInterfaceDeclaration() :
{
   SourceClass sourceClass = currentClass();
   Token it;
   Token name = null;
}
{
  it="interface" name=<IDENTIFIER>
  {
      // interfaces are always abstract
      sourceClass.addModifier( Modifier.ABSTRACT );

      if(sourceClass.isInner()) {
        sourceClass.setName(name.image);
        _xJavaDoc.addPackageMaybe( _packageName ).addClass(sourceClass);
        _xJavaDoc.addSourceClass( sourceClass );
      } else {
        sourceClass.setQualifiedName(Util.getQualifiedNameFor(_packageName,name.image));
        _xJavaDoc.addPackageMaybe( _packageName ).addClass(sourceClass);
        _xJavaDoc.addSourceClass( sourceClass );
        sourceClass.resolveImportedClasses();
      }

      sourceClass.setInterface( true );
      setToken(sourceClass,it);

  }
  [ "extends" Interfaces_NameList() ]
  "{"
  ( InterfaceMemberDeclaration() )*
  "}"
  
  {
    if(sourceClass.isInner()) {
        sourceClass.setName(name.image);
    }
  }
}

void InterfaceMemberDeclaration() :
{
}
{
  LOOKAHEAD( ( "static" | "abstract" | "final" | "public" | "protected" | "private" | "strictfp")* "class" )
  NestedClassDeclaration()
|
  LOOKAHEAD( ( "static" | "abstract" | "final" | "public" | "protected" | "private" | "strictfp")* "interface" )
  NestedInterfaceDeclaration()
|
  LOOKAHEAD( MethodDeclarationLookahead() )
  MethodDeclaration()
|
  FieldDeclaration()
}

void FieldDeclaration() :
{
   SourceClass sourceClass = currentClass();

   /* NOTE: We also support lame style like

   private static int a,b,c,d;

   They should share the same javadoc, type and modifiers
   */

   Token t = null;
   FieldImpl fieldImpl = null;
   fieldImpl = new FieldImpl(sourceClass, _tagFactory);
}
{
  (
  t="public" {
       fieldImpl.addModifier( Modifier.PUBLIC );
       setToken(fieldImpl,t);
    }
  | t="protected" {
       fieldImpl.addModifier( Modifier.PROTECTED );
       setToken(fieldImpl,t);
    }
  | t="private" {
       fieldImpl.addModifier( Modifier.PRIVATE );
       setToken(fieldImpl,t);
    }
  | t="static" {
       fieldImpl.addModifier( Modifier.STATIC );
       setToken(fieldImpl,t);
    }
  | t="final" {
       fieldImpl.addModifier( Modifier.FINAL );
       setToken(fieldImpl,t);
    }
  | t="transient" {
       fieldImpl.addModifier( Modifier.TRANSIENT );
       setToken(fieldImpl,t);
    }
  | t="volatile" {
       fieldImpl.addModifier( Modifier.VOLATILE );
       setToken(fieldImpl,t);
    }
  )*
  Field_Type(fieldImpl) FieldDeclarator(fieldImpl)
  (
     ","
     {
        FieldImpl badProgrammingStyleFieldImpl = new FieldImpl(sourceClass, _tagFactory);
        badProgrammingStyleFieldImpl.setType(fieldImpl.getTypeAsString());
     }
     FieldDeclarator(badProgrammingStyleFieldImpl) 
     {
        sourceClass.addField(badProgrammingStyleFieldImpl);
     }
  )*
  ";"
  {
    // we must add the field after parsing the field because the name must be set
    sourceClass.addField(fieldImpl);
  }
}

void FieldDeclarator(FieldImpl fieldImpl) :
{
}
{
  Field_VariableDeclaratorId(fieldImpl) [ "=" VariableInitializer() ]
}

void VariableDeclarator() :
{}
{
  VariableDeclaratorId() [ "=" VariableInitializer() ]
}

void Field_VariableDeclaratorId(FieldImpl fieldImpl) :
{
   Token t = null;
}
{
  t=<IDENTIFIER> ( "[" "]" { fieldImpl.setDimension(fieldImpl.getDimension() + 1); } )*
  {
     fieldImpl.setName( t.image );
  }
}

void Parameter_VariableDeclaratorId() :
{
   Token t = null;
}
{
  t=<IDENTIFIER> ( "[" "]" { _parameter.dimension++; } )*
  {
     _parameter.name = t.image;
  }
}

void VariableDeclaratorId() :
{}
{
  <IDENTIFIER> ( "[" "]" )*
}

void VariableInitializer() :
{}
{
  ArrayInitializer()
|
  Expression()
}

void ArrayInitializer() :
{}
{
  "{" [ VariableInitializer() ( LOOKAHEAD(2) "," VariableInitializer() )* ] [ "," ] "}"
}

void MethodDeclaration() :
{
   SourceClass sourceClass = currentClass();

   Token t = null;
   String exceptions = null;

   //this may remain null for anonymous inner classes (sourceClass==null), not a problem because we're not going to access class structure of an anonymous inner class
   MethodImpl methodImpl = null;

    if(sourceClass!=null) {
       methodImpl = new MethodImpl(sourceClass, _tagFactory);
    }
}
{
  (
  t="public" {
        if(methodImpl!=null) {
            methodImpl.addModifier( Modifier.PUBLIC );
            setToken( methodImpl, t );
        }
    }
  | t="protected" {
        if(methodImpl!=null) {
            methodImpl.addModifier( Modifier.PROTECTED );
            setToken( methodImpl, t );
        }
    }
  | t="private" {
        if(methodImpl!=null) {
            methodImpl.addModifier( Modifier.PRIVATE );
            setToken( methodImpl, t );
        }
    }
  | t="static" {
        if(methodImpl!=null) {
            methodImpl.addModifier( Modifier.STATIC );
            setToken( methodImpl, t );
        }
    }
  | t="abstract" {
        if(methodImpl!=null) {
            methodImpl.addModifier( Modifier.ABSTRACT );
            setToken( methodImpl, t );
        }
    }
  | t="final" {
        if(methodImpl!=null) {
            methodImpl.addModifier( Modifier.FINAL );
            setToken( methodImpl, t );
        }
    }
  | t="native" {
        if(methodImpl!=null) {
            methodImpl.addModifier( Modifier.NATIVE );
            setToken( methodImpl, t );
        }
    }
  | t="synchronized" {
        if(methodImpl!=null) {
            methodImpl.addModifier( Modifier.SYNCHRONIZED );
            setToken( methodImpl, t );
        }
    }
  | t="strictfp" {
        if(methodImpl!=null) {
            methodImpl.addModifier( Modifier.STRICT );
            setToken( methodImpl, t );
        }
    }
  )*
  ResultType(methodImpl)
  MethodDeclarator(methodImpl)
  [ "throws" ExecutableMemberThrows_NameList(methodImpl) ]
  ( Method_Block() | ";" )
  {
    // we must add the method after the fields are in, because the
    // signature must be complete when adding
    sourceClass.addMethod(methodImpl);
  }
}

void MethodDeclarator(MethodImpl methodImpl) :
{
   Token t = null;
}
{
  t=<IDENTIFIER> {
     if( methodImpl != null ) {
        methodImpl.setName( t.image );
     }
  }
  FormalParameters(methodImpl) ( "[" "]" {
     methodImpl.setReturnDimension( methodImpl.getReturnType().getDimension() + 1 );
  }
  )*
}

void FormalParameters(AbstractExecutableMember member) :
{}
{
  "(" [ FormalParameter(member) ( "," FormalParameter(member) )* ] ")"
}

void FormalParameter(AbstractExecutableMember member) :
{
   if(member != null) {
      // reset the _parameter helper's dimension
      _parameter.dimension = 0;
   }
}
{
  [ "final" ] Parameter_Type() Parameter_VariableDeclaratorId()
  {
     if( member != null ) {
        member.addParameterData(_parameter.type, _parameter.name, _parameter.dimension);
     }
  }
}

void ConstructorDeclaration() :
{
   SourceClass sourceClass = currentClass();
   Token t = null;
   ConstructorImpl constructor = constructor = new ConstructorImpl(sourceClass, _tagFactory);
}
{
  [
  t="public" {
       constructor.addModifier( Modifier.PUBLIC );
       setToken( constructor, t );
    }
  | t="protected" {
       constructor.addModifier( Modifier.PROTECTED );
       setToken( constructor, t );
    }
  | t="private" {
       constructor.addModifier( Modifier.PRIVATE );
       setToken( constructor, t );
    }
  ]
  <IDENTIFIER> FormalParameters(constructor) [ "throws" ExecutableMemberThrows_NameList(constructor) ]
  "{"
    [ LOOKAHEAD(ExplicitConstructorInvocation()) ExplicitConstructorInvocation() ]
    ( BlockStatement() )*
  "}"
  {
    // we must add the method after the fields are in, because the
    // signature must be complete when adding
    sourceClass.addConstructor(constructor);
  }
}

void ExplicitConstructorInvocation() :
{}
{
  LOOKAHEAD("this" Arguments() ";")
  "this" Arguments() ";"
|
  [ LOOKAHEAD(2) PrimaryExpression() "." ] "super" Arguments() ";"
}

void Initializer() :
{}
{
  [ "static" ] Block()
}


/*
 * Type, name and expression syntax follows.
 */

void Field_Type(FieldImpl fieldImpl) :
{
   Token typeToken;
   String type;
}
{
  ( typeToken=PrimitiveType()
    {
      if( fieldImpl != null ) {
        fieldImpl.setType(typeToken.image);
        setToken( fieldImpl, typeToken );
      }
    }
  | type=Name()
    {
      if( fieldImpl != null ) {
        fieldImpl.setType(type);
        setToken( fieldImpl, _nameToken );
      }
    }
  )
  ( "[" "]" {
     if( fieldImpl != null ) {
        fieldImpl.setDimension(fieldImpl.getDimension() + 1);
     }
  } )*
}

void MethodResult_Type(MethodImpl methodImpl) :
{
   Token typeToken;
   String type;
}
{
  ( typeToken=PrimitiveType()
    {
      if( methodImpl != null ) {
        methodImpl.setReturnType(typeToken.image);
        setToken( methodImpl, typeToken );
      }
    }
  | type=Name()
    {
      if( methodImpl != null ) {
        methodImpl.setReturnType(type);
        setToken( methodImpl, _nameToken );
      }
    }

  )
  ( "[" "]" {
     if( methodImpl != null ) {
        methodImpl.setReturnDimension(methodImpl.getReturnType().getDimension() + 1);
     }
  } )*
}

void Parameter_Type() :
{
   Token primitive;
   String name;
}
{
  ( primitive=PrimitiveType()
    {
       _parameter.type = primitive.image;
    }
  | name=Name()
    {
       _parameter.type = name;
    }
  )
  ( "[" "]" { _parameter.dimension++; } )*
}

void Type() :
{}
{
  ( PrimitiveType() | Name() )
  ( "[" "]" )*
}

Token PrimitiveType() :
{
   Token t = null;
}
{
  t="boolean" { return t; }
|
  t="char" { return t; }
|
  t="byte" { return t; }
|
  t="short" { return t; }
|
  t="int" { return t; }
|
  t="long" { return t; }
|
  t="float" { return t; }
|
  t="double" { return t; }
}

void ResultType(MethodImpl methodImpl) :
{
   Token t = null;
}
{
  t="void" {
     if( methodImpl != null ) {
        methodImpl.setReturnType( "void" );
        methodImpl.setReturnDimension( 0 );
        setToken( methodImpl, t );
     }
  }
|
  MethodResult_Type(methodImpl)
}

String Name() :
/*
 * A lookahead of 2 is required below since "Name" can be followed
 * by a ".*" when used in the context of an "ImportDeclaration".
 */
{
   // reset the buffer
   clearNameBuffer();
   Token t = null;
}
{
  _nameToken=<IDENTIFIER>
  {
     _nameBuffer.append(_nameToken.image);
  }
  ( LOOKAHEAD(2) "." t=<IDENTIFIER>
  {
     _nameBuffer.append(".").append(t.image);
  }
  )*
  {
     return _nameBuffer.toString();
  }
}

void ExecutableMemberThrows_Name(AbstractExecutableMember member) :
{
   // reset the buffer
   clearNameBuffer();
   Token t = null;
}
{
  t=<IDENTIFIER>
  {
     _nameBuffer.append(t.image);
  }
  ( "." t=<IDENTIFIER>
  {
     _nameBuffer.append(".").append(t.image);
  }
  )*
  {
     if( member != null ) {
        member.addThrownException( _nameBuffer.toString() );
     }
  }
}

void Interfaces_Name() :
{
   SourceClass sourceClass = currentClass();

   // reset the buffer
   clearNameBuffer();
   Token t = null;
}
{
  t=<IDENTIFIER>
  {
     _nameBuffer.append(t.image);
  }
  ( "." t=<IDENTIFIER>
  {
     _nameBuffer.append(".").append(t.image);
  }
  )*
  {
     sourceClass.addInterface( _nameBuffer.toString() );
  }
}

void NameList() :
{}
{
  Name() ( "," Name() )*
}

void ExecutableMemberThrows_NameList(AbstractExecutableMember member) :
{}
{
  ExecutableMemberThrows_Name(member)
  ( "," ExecutableMemberThrows_Name(member) )*
}

void Interfaces_NameList() :
{}
{
  Interfaces_Name()
  ( "," Interfaces_Name() )*
}


/*
 * Expression syntax follows.
 */

void Expression() :
/*
 * This expansion has been written this way instead of:
 *   Assignment() | ConditionalExpression()
 * for performance reasons.
 * However, it is a weakening of the grammar for it allows the LHS of
 * assignments to be any conditional expression whereas it can only be
 * a primary expression.  Consider adding a semantic predicate to work
 * around this.
 */
{}
{
  ConditionalExpression()
  [
    AssignmentOperator() Expression()
  ]
}

void AssignmentOperator() :
{}
{
  "=" | "*=" | "/=" | "%=" | "+=" | "-=" | "<<=" | ">>=" | ">>>=" | "&=" | "^=" | "|="
}

void ConditionalExpression() :
{}
{
  ConditionalOrExpression() [ "?" Expression() ":" ConditionalExpression() ]
}

void ConditionalOrExpression() :
{}
{
  ConditionalAndExpression() ( "||" ConditionalAndExpression() )*
}

void ConditionalAndExpression() :
{}
{
  InclusiveOrExpression() ( "&&" InclusiveOrExpression() )*
}

void InclusiveOrExpression() :
{}
{
  ExclusiveOrExpression() ( "|" ExclusiveOrExpression() )*
}

void ExclusiveOrExpression() :
{}
{
  AndExpression() ( "^" AndExpression() )*
}

void AndExpression() :
{}
{
  EqualityExpression() ( "&" EqualityExpression() )*
}

void EqualityExpression() :
{}
{
  InstanceOfExpression() ( ( "==" | "!=" ) InstanceOfExpression() )*
}

void InstanceOfExpression() :
{}
{
  RelationalExpression() [ "instanceof" Type() ]
}

void RelationalExpression() :
{}
{
  ShiftExpression() ( ( "<" | ">" | "<=" | ">=" ) ShiftExpression() )*
}

void ShiftExpression() :
{}
{
  AdditiveExpression() ( ( "<<" | ">>" | ">>>" ) AdditiveExpression() )*
}

void AdditiveExpression() :
{}
{
  MultiplicativeExpression() ( ( "+" | "-" ) MultiplicativeExpression() )*
}

void MultiplicativeExpression() :
{}
{
  UnaryExpression() ( ( "*" | "/" | "%" ) UnaryExpression() )*
}

void UnaryExpression() :
{}
{
  ( "+" | "-" ) UnaryExpression()
|
  PreIncrementExpression()
|
  PreDecrementExpression()
|
  UnaryExpressionNotPlusMinus()
}

void PreIncrementExpression() :
{}
{
  "++" PrimaryExpression()
}

void PreDecrementExpression() :
{}
{
  "--" PrimaryExpression()
}

void UnaryExpressionNotPlusMinus() :
{}
{
  ( "~" | "!" ) UnaryExpression()
|
  LOOKAHEAD( CastLookahead() )
  CastExpression()
|
  PostfixExpression()
}

// This production is to determine lookahead only.  The LOOKAHEAD specifications
// below are not used, but they are there just to indicate that we know about
// this.
void CastLookahead() :
{}
{
  LOOKAHEAD(2)
  "(" PrimitiveType()
|
  LOOKAHEAD("(" Name() "[")
  "(" Name() "[" "]"
|
  "(" Name() ")" ( "~" | "!" | "(" | <IDENTIFIER> | "this" | "super" | "new" | Literal() )
}

void PostfixExpression() :
{}
{
  PrimaryExpression() [ "++" | "--" ]
}

void CastExpression() :
{}
{
  LOOKAHEAD("(" PrimitiveType())
  "(" Type() ")" UnaryExpression()
|
// removed a LOOKAHEAD which was not technically needed DW, 7/99
  "(" Type() ")" UnaryExpressionNotPlusMinus()
}

void PrimaryExpression() :
{}
{
  PrimaryPrefix() ( LOOKAHEAD(2) PrimarySuffix() )*
}

void PrimaryPrefix() :
{}
{
  Literal()
|
  "this"
|
  "super" "." <IDENTIFIER>
|
  "(" Expression() ")"
|
  AllocationExpression()
|
  LOOKAHEAD( ResultType(null) "." "class" )
  ResultType(null) "." "class"
|
  Name()
}

void PrimarySuffix() :
{}
{
  LOOKAHEAD(2)
  "." "this"
|
  LOOKAHEAD(2)
  "." "super"
|
  LOOKAHEAD(2)
  "." AllocationExpression()
|
  "[" Expression() "]"
|
  "." <IDENTIFIER>
|
  Arguments()
}

void Literal() :
{}
{
  <INTEGER_LITERAL>
|
  <FLOATING_POINT_LITERAL>
|
  <CHARACTER_LITERAL>
|
  <STRING_LITERAL>
|
  BooleanLiteral()
|
  NullLiteral()
}

void BooleanLiteral() :
{}
{
  "true"
|
  "false"
}

void NullLiteral() :
{}
{
  "null"
}

void Arguments() :
{}
{
  "(" [ ArgumentList() ] ")"
}

void ArgumentList() :
{}
{
  Expression() ( "," Expression() )*
}

/**
 * @todo Anonymous classes will cause NPE. Need to check for nullity in a lot of places
 */
void AllocationExpression() :
{
   String realisedClass;
}
{
  LOOKAHEAD(2)
  "new" PrimitiveType() ArrayDimsAndInits()
|
  "new" realisedClass=Name()
    (
      ArrayDimsAndInits()
    |
      Arguments()
      [
      {
            // ANONYMOUS CLASS
            SourceClass containingClass = currentClass();
        pushAndGet();
      }
      ClassBody()
      {
        // Don't care about anonymous classes. They don't have javadocs
        // _xJavaDoc.addSourceClass(anonymousClass);
        currentClass().setName(containingClass.getNextAnonymousClassName());
        currentClass().setRealised(realisedClass);
        popAndAddInner();
      }
      ]
    )
}

/*
 * The second LOOKAHEAD specification below is to parse to PrimarySuffix
 * if there is an expression between the "[...]".
 */
void ArrayDimsAndInits() :
{}
{
  LOOKAHEAD(2)
  ( LOOKAHEAD(2) "[" Expression() "]" )+ ( LOOKAHEAD(2) "[" "]" )*
|
  ( "[" "]" )+ ArrayInitializer()
}


/*
 * Statement syntax follows.
 */

void Statement() :
{}
{
  LOOKAHEAD(2)
  LabeledStatement()
|
  Block()
|
  EmptyStatement()
|
  StatementExpression() ";"
|
  SwitchStatement()
|
  IfStatement()
|
  WhileStatement()
|
  DoStatement()
|
  ForStatement()
|
  BreakStatement()
|
  ContinueStatement()
|
  ReturnStatement()
|
  ThrowStatement()
|
  SynchronizedStatement()
|
  TryStatement()
|
  AssertStatement()
}

void LabeledStatement() :
{}
{
  <IDENTIFIER> ":" Statement()
}

void Block() :
{}
{
  "{" ( BlockStatement() )* "}"
}

void Method_Block() :
{}
{
  "{" ( Method_BlockStatement() )* "}" 
  // The last optional semicolon is illegal according to the official grammar,
  // but since javac allows it, we'll allow it too. However adding this in other
  // places than this results in a Choice conflict warning from javacc. That's
  // why we're not accepting semicolons after blocks and switches.
  ( ";" )?
}

/**
 * @todo not sure if the UnmodifiedClassDeclaration/UnmodifiedInterfaceDeclaration
 * ever get called, now that we have two different blocks. It would be nice to remove them
 */
void BlockStatement() :
{}
{
  LOOKAHEAD([ "final" ] Type() <IDENTIFIER>)
  LocalVariableDeclaration() ";"
|
  Statement()
|
  {
     pushAndGet();
  }
  UnmodifiedClassDeclaration()
  {
     popAndAddInner();
  }
|
  {
     pushAndGet();
  }
  UnmodifiedInterfaceDeclaration()
  {
     popAndAddInner();
  }
}

void Method_BlockStatement() :
{
}
{
  LOOKAHEAD([ "final" ] Type() <IDENTIFIER>)
  LocalVariableDeclaration() ";"
|
  Statement()
|
  {
     pushAndGet();
  }
  UnmodifiedClassDeclaration()
  {
     popAndAddInner();
  }
|
  {
     pushAndGet();
  }
  UnmodifiedInterfaceDeclaration()
  {
     popAndAddInner();
  }
}

void LocalVariableDeclaration() :
{}
{
  [ "final" ] Type() VariableDeclarator() ( "," VariableDeclarator() )*
}

void EmptyStatement() :
{}
{
  ";"
}

void StatementExpression() :
/*
 * The last expansion of this production accepts more than the legal
 * Java expansions for StatementExpression.  This expansion does not
 * use PostfixExpression for performance reasons.
 */
{}
{
  PreIncrementExpression()
|
  PreDecrementExpression()
|
  PrimaryExpression()
  [
    "++"
  |
    "--"
  |
    AssignmentOperator() Expression()
  ]
}

void SwitchStatement() :
{}
{
  "switch" "(" Expression() ")" "{"
    ( SwitchLabel() ( BlockStatement() )* )*
  "}"
}

void SwitchLabel() :
{}
{
  "case" Expression() ":"
|
  "default" ":"
}

void IfStatement() :
/*
 * The disambiguating algorithm of JavaCC automatically binds dangling
 * else's to the innermost if statement.  The LOOKAHEAD specification
 * is to tell JavaCC that we know what we are doing.
 */
{}
{
  "if" "(" Expression() ")" Statement() [ LOOKAHEAD(1) "else" Statement() ]
}

void WhileStatement() :
{}
{
  "while" "(" Expression() ")" Statement()
}

void DoStatement() :
{}
{
  "do" Statement() "while" "(" Expression() ")" ";"
}

void ForStatement() :
{}
{
  "for" "(" [ ForInit() ] ";" [ Expression() ] ";" [ ForUpdate() ] ")" Statement()
}

void ForInit() :
{}
{
  LOOKAHEAD( [ "final" ] Type() <IDENTIFIER> )
  LocalVariableDeclaration()
|
  StatementExpressionList()
}

void StatementExpressionList() :
{}
{
  StatementExpression() ( "," StatementExpression() )*
}

void ForUpdate() :
{}
{
  StatementExpressionList()
}

void BreakStatement() :
{}
{
  "break" [ <IDENTIFIER> ] ";"
}

void ContinueStatement() :
{}
{
  "continue" [ <IDENTIFIER> ] ";"
}

void ReturnStatement() :
{}
{
  "return" [ Expression() ] ";"
}

void ThrowStatement() :
{}
{
  "throw" Expression() ";"
}

void SynchronizedStatement() :
{}
{
  "synchronized" "(" Expression() ")" Block()
}

void TryStatement() :
/*
 * Semantic check required here to make sure that at least one
 * finally/catch is present.
 */
{}
{
  "try" Block()
  ( "catch" "(" FormalParameter(null) ")" Block() )*
  [ "finally" Block() ]
}

void AssertStatement() :
{}
{
  "assert" Expression() [ ":" Expression() ] ";"
}

